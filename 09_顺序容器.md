<center>09. 顺序容器</center>
-----
[TOC]

一个容器就是一些特定类型对象的集合。标准库中容器分为顺序容器和关联容器。顺序容器中元素的位置与其加入容器时的顺序相对应。关联容器中元素的位置由元素相关联的关键字值决定。

所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展。这个公共接口使容器的学习更加容易——我们基于容易所学习的内容也适用于其他容器。每种容器都提供了不同的性能和功能的权衡。

对于一个容器，与之相关的类型及类型别名有如下几种：

- 容器类型（）：容器的类型，即类模板，如 array、vector、map 等。
- 迭代器类型（iterator、const_iterator）：可以间接访问容器内的元素的类型，对迭代器进行解引用可得到容器内的元素，如 begin、end 等容器的成员函数的返回值。
- 元素类型（value_type）：容器内的元素的类型，即类，如 map 内元素类型为 pair。

# 1. 容器库概述

容器类型上的操作形成了一种层次：

- 某些操作是所有容器类型都提供的（如本节的容器操作）。例如构造函数、赋值/交换、迭代器、大小、关系运算符等。
- 另外一些操作仅针对顺序容器或关联容器。
  - 顺序容器：添加、删除，访问
  - 关联容器：添加、删除，访问/查找
- 还有一些操作只适用于一小部分容器。例如链表操作。

在本节中，我们将介绍对所有容器都适用的操作。如下表所示（C 表示容器类型）：

| 容器操作                   |                                                |
| -------------------------- | ---------------------------------------------- |
| **类型别名**               |                                                |
| iterator、const_iterator   | 迭代器类型、只读元素的迭代器类型               |
| size_type                  | 无符号整数类型。容器的大小。                   |
| difference_type            | 带符号整数类型。两个迭代器之间的距离           |
| value_type                 | 元素类型                                       |
| reference、const_reference | value_type &;        const value_type &        |
| **获取迭代器**             |                                                |
| c.begin()、c.end()         | 返回指向 c 的首元素和尾元素之后位置的迭代器    |
| c.cbegin()、c.cend()       | 返回                                           |
| **构造函数**               |                                                |
| `C c;`                     | 默认构造函数，构造空容器                       |
| `C c(d);`                  | 构造 c，d 的拷贝                               |
| `C c(b, e);`               | 构造 c，将迭代器 b 和 e 范围内的元素拷贝到 c   |
| `C c{a, b, c...};`         | 列表初始化 c                                   |
| **赋值/交换**              |                                                |
| c1 = c2                    | 将 c1 中的元素替换为 c2 中元素                 |
| c1 = {a, b, c, ...}        | 将 c1 中的元素替换为列表中元素（不支持 array） |
| a.swap(b)、swap(a, b)      | 交换 a 和 b 的元素                             |
| **大小**                   |                                                |
| c.size()                   | c 中元素的数目（不支持 forward_list）          |
| c.max_size()               | c 中可保存元素的最大数目                       |
| c.empty()                  | 判断 c 是否为空                                |
| **关系运算符**             |                                                |
| ==、!=                     | 所有容器都支持相等/不等运算符                  |
| <、<=、>、>=               | 关系运算符（无序容器不支持）                   |

## 1.1 迭代器

容器迭代器支持的操作在第三章已经列出，唯一例外的是 forward_list 迭代器不支持递减操作符。

begin 和 end 操作生成指向容器中第一个元素和尾元素之后位置的迭代器。当 auto 与 begin 或 end 结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器无关。

## 1.2 容器定义和初始化

每个容器类型都定义了一个默认构造函数。除 array 之外，其他容器的默认构造函数都会创建一个指定类型的空容器（array 要求指定大小）。除 array 之外，其他顺序容器都可以接受指定容器大小和元素初始值的参数。

**初始化容器为另一个容器的拷贝**

将一个容器初始化为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器；或者（array 除外）拷贝由一个迭代器对指定的元素范围。

直接拷贝整个容器时要求两个容器的类型及其元素类型必须匹配；拷贝一个迭代器对范围时容器类型可以不相同。

**列表初始化**

使用一个列表对容器初始化，此时容器包含与列表相同个数的元素。

**array 具有固定大小**

与内置数组一样，标准库 array 的大小也是类型的一部分。即当定义一个 array 时，除了指定元素类型，还要指定容器大小。此外对 array 的其他操作也应考虑元素类型和容器大小。

## 1.3 赋值/交换

**交换**

swap 操作交换两个相同类型容器的内容。除 array 外，swap 不对任何元素进行拷贝、删除或插入操作，只是交换了两个容器的内部数据结构。

- 对 string 调用 swap， 会导致指向容器的迭代器、引用和指针失效。
- 对 array 调用 swap，会真正交换它们的元素，迭代器、引用和指针所绑定的元素保持不变，属于交换前的容器。
- 除 string、array 外调用 swap，只是交换了两个容器的内部数据结构，迭代器、引用和指针所绑定的元素保持不变，但已经属于交换后的容器。

## 1.4 关系运算符

每个容器类型都支持相等运算符 `==`、`!=`；除了无序关联容器外的所有容器都支持关系运算符 `<`、`<=`、`>`、`>=`。

- 关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。
- 容器的关系运算符是使用元素的关系运算符完成比较的。如果容器内的元素不支持某种运算符，那么该容器就不能使用相应的关系运算。

# 2. 顺序容器概述

下表列出了标准库中的顺序容器，所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在一下方面都有不同的性能折中：

- 非顺序访问容器中元素的代价；
- 容器中插入或删除元素的代价。

|     类型     |          描述          |        访问        |          插入/删除          |
| :----------: | :--------------------: | :----------------: | :-------------------------: |
|    array     |      固定大小数组      |  支持快速随机访问  |      不能插入/删除元素      |
|    vector    |      可变大小数组      |  支持快速随机访问  |   在尾部插入/删除速度很快   |
|    string    | 与vector相似，保存字符 |  支持快速随机访问  |   在尾部插入/删除速度很快   |
|    deque     |        双端队列        |  支持快速随机访问  | 在头尾位置插入/删除速度很快 |
|     list     |        双向链表        | 只支持双向顺序访问 |  任意位置插入/删除速度很快  |
| forward_list |        单向链表        | 只支持单向顺序访问 |  任意位置插入/删除速度很快  |

与内置数组相比，array 是一种更安全、更容易使用的数组类型。通常情况下，使用 vector 是最好的选择，除非有确定的理由选择其他容器。

# 3. 顺序容器操作

顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到元素如何存储、访问、增加和删除。

## 3.1 添加元素

除 array 外，所有标准容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器的大小。

```c++
// array 不支持这些操作

// vector 和 string 不支持 push_front 和 emplace_front
// forward_list 不支持 push_back 和 emplace_back
c.push_front(t)			// 在 c 的头部创建一个值为 t 的元素或由 args 构造的元素。返回 void
c.emplace_front(args)	// 在调用 emplace* 时，会在容器管理的内存空间中直接构造元素

c.push_back(t)			// 在 c 的尾部创建一个值为 t 或由 args 构造的元素。返回 void
c.emplace_back(args)	//

// forward_list 有自己专有版本的 insert 和 emplace
c.insert(p, t)			// 在迭代器 p 指向的元素之前插入一个值为 t 或由 args 创建的元素。返回
c.emplace(p, args)		// 指向新添加的元素的迭代器

c.insert(p, b, e)		// 在迭代器 p 指向的元素之前插入迭代器 b 和 e 指定范围内的元素，b、e 不能
						// 指向 c 中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，返回 p
c.insert(p, n, t)		// 在迭代器 p 指向的元素之前插入 n 个值为 t 的元素。返回
						// 指向新添加的第一个元素的迭代器；若 n 为 0， 返回 p
c.insert(p, il)			// 在迭代器 p 指向的元素之前插入一个花括号包围的元素值列表。返回
    					// 指向新添加的第一个元素的迭代器；若列表为空， 返回 p
```

## 3.2 删除元素

```c++
// array 不支持这些操作

// vector 和 string 不支持 pop_front
// forward_list 不支持 pop_back()
c.pop_front()			// 删除 c 中尾元素。若 c 为空，该函数行为未定义。返回 void
c.pop_back()			// 删除 c 中首元素。若 c 为空，该函数行为未定义。返回 void

// forward_list 有自己专有版本的 erase
c.erase(p)				// 删除迭代器 p 所指定的元素，返回一个指向被删元素之后元素的迭代器。若 p 是
    					// 尾后迭代器，该函数行为未定义。
c.erase(b, e)			// 删除迭代器 b 和 e 范围内的元素。返回一个指向最后被删元素之后元素的迭代器

c.clear()				// 删除 c 中的所有元素。返回 void
```

## 3.3 访问元素

```c++
// forward_list 不支持 back
c.front()				// 返回 c 中首元素的引用。若 c 为空，该函数行为未定义
c.back()				// 返回 c 中尾元素的引用。若 c 为空，该函数行为未定义

// at 和下标操作只适用于 array、vector、string 和 deque
c[n]					// 返回 c 中下标为 n 元素的引用。n 是一个无符号整数。
    					// 若 n >= c.size()，该函数行为未定义
c.at(n)					// 若 n 越界，抛出一个 out_of_range 异常
```

## 3.4 改变容器大小

```c++
// array 不支持这些操。若
c.resize(n)				// 调整 c 的大小为 n 个元素。若 n < c.size()，则多出的元素被抛弃；
    					// 若必须添加新元素，对新元素进行值初始化。
c.resize(n, t)			// 调整 c 的大小为 n 个元素。任何新添加的元素都初始化为值 t
```

## 3.5 forward_list 操作

forward_list 是一个单向链表。在单向链表中，没有简单的方法来获取一个元素的前驱。因此，在 forward_list 中添加或删除元素是通过改变给定元素之后的元素来完成的。

故 forward_list 并未定义 insert、emplace 和 erase，而是定义了名为 insert_after、emplace_after 和 erase_after 的操作，在给定的位置 p 之后进行操作。为了支持这些操作，forward_list 也定义了 before_begin，它返回一个**首前**迭代器，返回链表首元素之前不存在的元素的迭代器（类似尾后迭代器）。

## 3.6 容器操作可能使迭代器失效

向容器中添加/删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。一个失效的指针、引用或迭代器将不在表示任何元素。使用失效的指针、引用或迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。

向容器添加元素后：

- 对于 vector 和 string，如果储存空间被重新分配，会使所有迭代器、指针和引用失效；如果储存空间没有重新分配，指向插入元素之前的迭代器、指针和引用仍然有效。
- 对于 deque，如果插入除首尾之外的任何位置，会使所有迭代器、指针和引用失效；如果插入到首尾，迭代器会失效，但指向存在的元素的引用和指针不会失效。
- 对于 list 和 forward_list，指向容器的迭代器（包括尾后和首前迭代器）、引用和指针仍有效。

从容器删除元素后，指向被删除元素的迭代器、指针和引用会失效，

- 对于 vector 和 string，指向被删除元素之前元素的迭代器、指针和引用仍然有效。
- 对于 deque，如果删除除首尾之外的任何元素，会使所有迭代器、指针和引用失效；如果删除尾元素，尾后迭代器会失效；如果删除首元素，指向其他位置的这些都不会失效。
- 对于 list 和 forward_list，指向容器其他位置的迭代器（包括尾后和首前迭代器）、引用和指针仍有效。

==注意==：不要保存 end 返回的迭代器

如果在一个循环中添加/删除 vector、string、deque 中的元素，不要缓存 end 返回的迭代器。即：

```c++
auto begin = v.begin(), end = v.end();
while (begin != end) { ... }	// 这是错误写法，循环体内添加/删除元素后，end 就失效了，代码会出错
while (being != v.end()) { ... }// 这是正确写法，每次都重新读取 end
```

# 4. 额外的 string 操作

除了顺序容器共同的操作之外，string 还提供了一些额外的操作。这些操作中的大部分要么是提供 string 类和 C 风格字符数组之间的相互转换，要么是增加了允许我们用下标代替迭代器的版本。

==未完待续==

# 5. 容器适配器

除了顺序容器外，标准库还定义了三个顺序容器适配器：stack、queue 和 priority_queue。**适配器**（adaptor）是标准库中的一个通用概念。容器、迭代器和函数都有适配器。

本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其行为看起来像一种不同的类型。所有容器适配器都支持的操作和类型如下：

|                       |                                                           |
| --------------------- | --------------------------------------------------------- |
| size_type             | 容器迭代器的大小                                          |
| value_type            | 元素类型                                                  |
| container_type        | 实现容器适配器的底层容器类型                              |
| `A a;`                | 创建一个名为 a 的空容器适配器                             |
| `A a(c);`             | 创建一个名为 a 的容器适配器，是容器 c 的一个拷贝          |
| 关系运算符            | 支持所有关系运算符，返回底层容器的比较结果                |
| a.size()              | a 中元素的数目                                            |
| a.empty()             | 判断 a 是否为空                                           |
| a.swap(b)、swap(a, b) | 交换 a、b 的内容，a 和 b 必须有相同类型，包括底层容器类型 |

**定义一个容器适配器**

每个容器适配器都定义两个构造函数：默认构造函数，创建一个空对象；接受一个容器的构造函数，拷贝该容器

来初始化容器适配器。

- 使用默认构造函数时，容器适配器的实现为默认情况，即 stack 和 queue 是基于 deque 实现的，priority_queue 是基于 vector 实现的。

- 使用接受容器的构造函数时，容器适配器的实现可被被重载，即在创建时将一个命名的顺序容器作为第二个类型参数传入

  ```c++
  stack<string, vector<string>> str_stk(svec);
  ```

## 5.1 栈适配器

stack 类型定义在 stack 头文件中。

```c++
// stack 默认基于 deque 实现，也可以在 vector 和 list 上实现
s.pop()				// 删除栈顶元素，但不返回该元素
s.push(item)		// 创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来，
s.emplace(args)		// 或者由 args 构造

s.top()				// 返回栈顶元素，但不将元素弹出栈
```

## 5.2 队列适配器

queue 和 priority_queue 适配器定义在 queue 头文件中。

```c++
// queue 默认基于 deque 实现，也可以在 vector 和 list 上实现
// priority_queue 默认基于 vector 实现，也可以在 deque 上实现
q.pop()				// 删除 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回该元素
q.push()			// 创建一个新元素在 queue 末尾或 priority_queue 中恰当的位置，其值为 item，
q.emplace(args)		// 或者由 args 构造

q.front()			// 返回首元素或尾元素，但不删除该元素，只适用于 queue
q.back()
q.top()				// 返回最高优先级元素，但不删除该元素，只适用于 priority_queue
```