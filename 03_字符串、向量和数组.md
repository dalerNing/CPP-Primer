<center>03. 字符串、向量和数组</center>
-----
[TOC]

除了第 2 章介绍的内置类型之外，C++语言还定义了一个内容丰富的抽象数据类型库。其中，**string** 和 **vector** 是两种最重要的标准库类型，string 表示可变长的字符序列，vector 表示的是某种给定类型对象的可变长集合。还有一种标准库类型是**迭代器**，它是 string 和 vector 的配套类型，常被用于访问 string 中的字符或 vector 中的元素。**内置数组**是一种更基础的类型，string 和 vector 都是对它的某种抽象。

# 1. 命名空间的 using 声明

目前为止，我们用到的库函数基本上都属于命名空间 std，程序也显式得将这一点标识了出来，例如 std::cin、std::cout 等。上面的方法显得比较烦琐，实际上可以使用一种简单的途径，即 **using 声明**（using declaration）来使用命名空间中的成员。

```c++
using namespace::name;	// using 声明的形式
using std::cin;			// 例子
```

一旦声明了上述语句，就可以直接访问命名空间中的名字，如 cin 可以直接使用。注意：

**命名空间内的每个名字都需要独立的 using 声明**

**头文件不应包含 using 声明**

# 2. 标准库类型 string

标准库类型 **string** 表示可变长的字符序列。

## 2.1 string 对象的定义和初始化

初始化 string 对象的方法有如下几种：

```c++
#include <string>
using std::string;

string s1;				// 默认初始化，s1 是一个空串
string s2(s1);			// s2 是 s1 的副本
string s2 = s1;			// 等价于 s2(s1)
string s3("value");		// s3 是 "value" 的副本
string s3 = "value";	// 等价于 s3("value")
string s4(n , 'c');		// 把 s4 初始化为由连续 n 个字符 c 组成的串
```

- **直接初始化**：如果不使用等号，则执行的是直接初始化。
- **拷贝初始化**：如果使用等号初始化一个变量，实际上执行的是拷贝初始化，编译器把等号右侧的初始值拷贝到新创建的对象中去。

## 2.2 string 对象上的操作

string 支持的操作：

```c++
os << s				// 将 s 写到输出流 os 当中，返回 os
is >> s				// 从输入流 is 中读取字符串赋给 s，字符串以空白分隔，返回 is
getline(is, s)		// 从输入流 is 中读取一行赋给 s，返回 is
s.empty()			// 判断 s 是否为空
s.size()			// 返回 s 中字符的个数，类型为 string::size_type 类型
s[n]				// 返回 s 中第 n 个字符的引用，位置 n 从 0 计起
s1 + s2				// 返回 s1 和 s2 连接后的结果
s1 = s2				// 用 s2 的副本代替 s1 中原来的字符
s1 == s2			// 判断 s1 和 s2 是否相同
s1 != s2			// 判断 s1 和 s2 是否不同
<, <=, >, >=		// 利用字符的字典序进行比较
```

从输入流读取字符串赋给 string 对象时，string 对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。

当把 string 对象与字符串字面值相加时，必须确保每个加法云算符的两侧的对象至少有一个是 string。

## 2.3 string 对象中的字符

处理 string 对象中的字符，可以使用**范围 for 语句**（range for）或者**下标运算符**（`[]`）。

```c++
// 使用范围 for 语句输出字符串中的字符
for (auto c: str)
    cout << c << endl;
// 使用范围 for 语句改变字符串中的字符----定义成引用类型
for (auto &c: str)
    c = toupper(c);
// 使用下标运算符----可直接输出或改变
if (!s.empty())
    s[0] = toupper(s[0]);	// 为 s 的第一个字符赋值
```

# 3. 标准库类型 vector

标准库类型 **vector** 表示**对象的集合**，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。因为 vector "容纳着" 其他对象，所以它也被称作**容器**（container）。

C++语言既有**类模板**（class template），也有**函数模板**（function template），其中 vector 是一个类模板。**模板**本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为**实例化**（ubstabtiation）。**当使用模板时，需要指出编译器应把类或函数实例化成何种类型。**

## 3.1 vector 对象的定义和初始化

初始化 vector 对象的方法有如下几种：

```c++
#include <vector>
using std::vector;

vector<T> v1				// v1 是一个空 vector，它潜在的元素是 T 类型的，执行默认初始化
vector<T> v2(v1)			// v2 中包含有 v1 所以元素的副本
vector<T> v2 = v1			// 等价于 v2(v1)
vector<T> v3(n, val)		// v3 包含了 n 个重复的元素，每个元素的值都是 val
vector<T> v4(n)				// v4 包含了 n 个重复地执行了值初始化的对象
vector<T> v5{a, b, c...}	// v5 包含了初始值个数的元素，每个元素被赋予相应的初始值
vector<T> v5 = {a, b, c...}	// 等价于 v5{a, b, c...}
```

即：

- 如果用的是圆括号，提供的值是用来**构造**（construct）vector 对象的。

- 如果用的是花括号，提供的值是想**列表初始化**（list initialize）vector 对象的。

- 如果用的是花括号，但是提供的值又不能用来列表初始化，则编译器会尝试构造 vector 对象。如下：

  ```c++
  vector<string> v8{10, "hi"};	// v8 有 10 个值为 "hi" 的元素
  ```

vector 能容纳绝大多数类型的对象作为其元素，但是引用不是对象，所以不存在包含引用的 vector。

**范围 for 语句内不应改变其所遍历序列的大小。**

## 3.2 vector 对象上的操作

vectoe 支持的操作：

```c++
v.empty()		// 判断 v 是否为空
v.size()		// 返回 v 中元素的个数，
    			// 类型为 vectot<T>::size_type 类型（T 表示该 vector 对象的类型）
v.push_back(t)	// 向 v 的尾端添加一个值为 t 的元素
v[n]			// 返回 v 中第 n 个位置上元素的引用，用于访问已存在的元素，不能用于添加元素 
v1 = v2			// 用 v2 中元素的拷贝替换 v1 中的元素
v1 == v2		// 判断 v1 和 v2 是否相同
v1 != v2		// 判断 v1 和 v2 是否不同
<, <=, >, >=	// 以字典顺序进行比较
```

# 4. 迭代器

**迭代器**（iterator）：所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。迭代器提供了对对象的间接访问，即其对象是容器中的元素。使用迭代器可以访问某个元素，也能从一个元素移动到另一个元素。

> 严格来说，string 对象不属于容器类型，但是 string 支持很多与容器类型类似的操作，例如迭代器。

迭代器分有效和无效：有效的迭代器或者指向某个元素，或者指向容器尾元素的下一位置；其他情况都属于无效。

## 4.1 使用迭代器

和指针不同的是，获取迭代器不是使用取地址符。事实上，有迭代器的类型同时拥有返回迭代器的成员；比如，这些类型都拥有名为 `begin` 和 `end` 的成员，其中 `begin` 成员返回指向第一个元素的迭代器；`end` 成员返回指向容器 “尾元素” 的下一个位置的迭代器，即指向一个本不存在的 “尾后” 元素，这样的迭代器常被称作尾后迭代器。

```c++
// b 指向 v 的第一个元素， e 指向 v 最后一个元素的下一位置
auto b = v.begin(), e = v.end();		// b 和 e 是迭代器
```

标准容器迭代器的运算符：

```c++
// iter 是一个迭代器
*iter			// 返回迭代器 iter 所指元素的引用
iter->mem		// 解引用 iter 并获取该元素的名为 mem 的成员，等价于 (*iter).mem
++iter			// 令 iter 指示容器中的下一个元素
--iter			// 令 iter 指示容器中的上一个元素
iter1 == iter2	// 判断两个迭代器是否相等
iter1 != iter2	// 判断两个迭代器是否不等
```

**迭代器类型**

就像不知道 string 和 vector 的 size_type 成员到底是什么类型一样，一般来说我们也不用知道迭代器的具体类型。实际上，那些拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型：

```c++
vector<int>::iterator it;			// it 能读写 vector<int> 的元素
vector<int>::const_iterator it2;	// it2 只能读元素，不能写元素
```

const_iterator 和指向常量的指针差不多，能读取但不能修改它所指的元素值。

**使用了迭代器的循环体中，不要向迭代器所属的容器添加元素。**

## 4.2 迭代器运算

除了标准容器迭代器的运算符，vector 和 string 的迭代器提供了更多额外的运算符：一方面可使得迭代器的每次移动跨过多个元素；另外也使得迭代器支持关系运算。所有这些运算被称为**迭代器运算**，如下：

```c++
iter + n		// 迭代器加上一个整数值仍是一个迭代器，表示迭代器的新位置向后移动了 n 个元素
iter - n		// 迭代器减去一个整数值仍是一个迭代器，表示迭代器的新位置向前移动了 n 个元素
iter1 += n		// 迭代器加法的复合赋值语句
iter1 -= n		// 迭代器减法的复合赋值语句
iter1 - iter2	// 表示两个迭代器之间的距离
<, <=, >, >=	// 迭代器的关系运算符，如果某个迭代器指向的容器位置在另一个之前，说明前者小于后者
```

# 5. 数组

数组是一种复合类型。

## 5.1 数组的定义和初始化

数组的声明形式如 `a[d]`，其中 a 是数组的名字，d 是数组的维度（前面还要加上数组内存放的元素的类型，如 `int a[10]`）。默认情况下，数组的元素被默认初始化。

**不允许拷贝和赋值**

不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值

## 5.2 数组指针

和 vector 一样，数组能存放大多数类型的对象。如下示例：

```c++
int *ptrs[10];				// ptrs 是含有 10 个整形指针的数组
int &refs[10] = /*  ? */;	// 错误：不存在引用的数组
int (*Parray)[10] = &arr;	// Parray 指向一个含有 10 个整数的数组
int (*arrRef)[10] = arr;	// arrRef 引用一个含有 10 个整数的数组
```

通过以上的复杂的数组声明，我们又学到了声明的另一种理解方式：1. 默认情况下的从右向左的阅读方式；对数组名字的由内向外的阅读方式。

此外，对于对象 Parray，其表示一个指向数组的指针，我们可以简称为**数组指针**。

