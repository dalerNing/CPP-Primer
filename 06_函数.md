<center>06. 函数</center>
-----
[TOC]

函数是一个命名了的代码块，我们通过调用函数执行相应的代码。

# 1. 函数基础

一个典型的**函数**（function）定义包括以下部分：**返回类型**（return type）、**函数名字**（function name）、由零个或多个**形参**（parameter）组成的列表以及**函数体**。

**形参和实参**：实参是形参的初始值，实参的类型必须与对应的形参类型匹配。

**返回类型**：函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。

## 1.1 函数声明

类似于变量，函数只能定义一次，但可以声明多次。函数声明与函数定义非常相似，唯一的区别是函数声明无须函数体。函数声明也称作**函数原型**（function prototype）。

> 对于变量和函数，我们建议在头文件中声明，在源文件中定义。

## 1.2 参数传递

- **传值调用**（called by value）：当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的函数被传递调用。
- **传引用调用**（called by reference）：当形参是引用类型时，我们说这样的函数被传引用调用。和其他引用一样，引用形参是它对应的实参的别名。

### 1. 传值参数

当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。

这里以分析**指针形参**为例。当执行指针拷贝时：拷贝的是指针的值，即指针所指对象的地址；拷贝之后，两个指针是不同的指针。

```c++
// 该函数接受一个指针，对指针所指的对象进行了修改
void reset(int *ip) {
    *ip = 20;			// 改变了指针 ip 所指对象的值
    ip = 0;				// 只改变了 ip 的局部拷贝，调用函数中的 ip 所指对象不变
}
```

### 2. 传引用参数

使用引用形参，允许函数改变一个或多个实参的值。

这里以分析**指向指针的引用形参**为例。此时，函数通过引用不仅改变了指针所指对象的值，还改变了指针的值。

```c++
// 该函数接受一个指向指针的引用，对指针所指的对象及指针进行了修改
void reset(int *&rp) {
    *rp = 20;			// 改变了 rp 所引用指针的所指对象的值
    rp = 0;				// 改变了 rp 所引用指针的值
}
```

拷贝大的类对象或者容器对象比较低效，甚至有的类对象根本就不支持拷贝操作。此时使用引用形参较为明智。

### 3. const 形参和实参

我们首先来回顾一下通用的初始化规则：

- 实参初始化形参时会忽略掉顶层 const。

- 对于非常量、顶层 const 和 底层 const 来说，除了不能用底层const 初始化非常量和顶层 const 外，另外 7 种组合都可运行。
- 一个朴素的引用必须用同类型的对象初始化。

形参的初始化方式和变量的初始化方式是一样的，故可以应用上述的初始化规则分析 const 形参的初始化过程。

**尽量使用对常量的引用**

1. 把函数不会改变的形参定义成普通的引用是一种比较常见的错误，这么做带给函数的调用者一种错觉，即函数可以修改它的实参的值。
2. 使用引用而非常量引用也会极大地限制函数所能接受的实参类型。（即我们不能把 const 对象等传递给普通的引用形参，因为引用形参必须用同类型的对象初始化）

### 4. 数组形参

数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：不允许拷贝数组；使用数组时会将其转换成指针。故当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

```c++
// 尽管形式不同，但这三个函数是等价的，都有一个 const int * 类型的形参
void print(const int *);
void print(const int[]);
void print(const int[10]);	// 这里的维度表示我们期望数组含有多少元素，实际在函数中并没有实际作用
```

由于数组是以指针的形式传递给函数，所以函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。有如下三种常用的技术：

- 使用标记指定数组长度
- 使用标准库规范
- 显示传递一个表示数组大小的形参

## 1.3 返回类型

return 语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。return 语句有两种形式：

```c++
return;
return expression;
```

当函数有返回值时，返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时变量，该临时量就是函数调用的结果。

**不要返回局部对象的引用或指针**：函数完成后，它所占用的存储空间也随之被释放掉。因此返回局部对象的引用或指针是错误的。

**调用一个返回引用的函数得到左值，其他类型右值**：返回引用的函数，其返回值可以作为左值。

> 左值：即可以出现在等号左边，又可以出现在等号右边。
>
> 右值：只能出现在等号右边。

**返回数组指针**：因为数组不能被拷贝，所以函数不能返回数组，但是可以返回指向数组的指针或引用。

# 2. 函数重载

如果同一作用域内的几个**函数名字相同但形参列表不同**，我们称之为**重载函数**（overloaded）。（没有规定返回类型相同，所以重载函数的关键是：函数名字相同；形参列表不同）例如：

```c++
void print(const char *cp);
void print(const int *beg, const int *end);
void print(const int ia[], size_t size);
```

这些函数接受的形参列表不一样，但是执行的操作非常类似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。

**const 形参和重载**

1. 顶层 const 不影响传入函数的对象。一个拥有顶层 const 的形参无法和另一个没有顶层 const 的形参区分开来。
2. 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的 const 是底层的。

**const_cast 和重载**

const_cast 在函数重载的情景一般如下：

```c++
// 比较两个 string 对象的长度，返回较短的那个引用
const string &shorterString(const string &s1, const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}

string &shorterString(string &s1, string &s2) {
    auto &r = shorterString(const_cast<const string &>(s1),
                            const_cast<const string &>(s2));
    return const_cast<string &>(r);
}
```

**调用重载的函数**

**函数匹配**（function matching）是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做**重载确定**（overload resolution）。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。当调用重载函数时有三种可能的结果：

- 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
- 找不到任何一个函数与实参匹配，此时编译器发出无匹配的错误信息。
- 有多于一个函数可以匹配，但是每个都不是明显的最佳选择。此时也将发生错误，称为二义性调用。

# 3. 特殊用途语言特性

## 3.1 默认实参

调用含有默认实参的函数时，可以包含该参数，也可以省略该实参。

- 一个某个形参被赋予了默认值，它后面的所有形参都必须有默认值。
- 函数调用时实参时按其位置解析，默认实参负责填补函数调用缺少的尾部实参。

## 3.2 内联函数

对于较小规模的操作定义成函数也存在一些潜在的缺点：调用函数一般比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。

**内联函数可避免函数调用的开销**

将函数指定为**内联函数（inline）**，通常就是将它在每个调用点上 “内联地” 展开（在**编译阶段**展开）。在 shorterString 函数的返回类型前面加上关键字 inline，这样就可以把它声明成内联函数了：

```c++
inline const string & shorterString(const string &s1, const string &s2){
    return s1.size() <= s2.size() ? s1 : s2;
}
```

## 3.3 constexpr 函数

**constexpr 函数**是指能用于常量表达式的函数。定义 constexpr 函数的方法与其他函数类似，不过有如下规定：

- 函数的返回类型及所以形参的类型都得是字面值类型；
- 函数体中必须有且只有一条 return语句。

constexpr 函数不一定返回常量表达式；隐式地指定为内联函数。

```c++
constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();			// 正确：foo 是一个常量表达式
```

**把内联函数和 constexpr 函数放在头文件内**

# 4. 函数指针

**函数指针**指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，**与函数名无关**。例如：

```c++
// 比较两个 string 对象的长度
bool lengthCompare(const string &, const string &);
```

该函数的类型是 bool(const string &, const string &)。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可。

```c++
// pf 指向一个函数
bool (*pf)(const string &, const string &);

pf = lengthCompare;								// pf 指向名为 lengthCompare 的函数
bool b1 = pf(const string &, const string &);	// 调用 lengthCompare 函数
```

**指向重载函数的指针**

当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针，编译器**通过指针类型（即这个函数指针的返回类型和形参类型）**决定选用哪个函数。

**函数指针形参**

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。如下：

```c++
// 第三个形参为指向函数的指针
void useBigger(const string &s1, const string &s2, 
               bool (*pf)(const string &, const string &));
```

直接使用函数指针显得冗长和繁琐，typedef 和 decltype 能让我们简化使用函数指针的代码：

```c++
// FuncP 和 FuncP2 是指向函数的指针
typedef bool (*FuncP)(const string &, const string &);
typedef decltype(lengthCompare) *FuncP2;	// 等价的类型

// useBigger 的等价声明，其中使用了类型别名
void useBigger(const string &s1, const string &s2, FuncP2);
```

**返回函数指针**

和数组类似，虽然不能返回一个函数，但是能返回指向函数类型的指针。

