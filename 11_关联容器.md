<center>11. 关联容器</center>
-----
[TOC]

关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。

# 1. 关联容器概述

关联容器支持高效的关键字查找和访问。两个主要的**关联容器**（associative-container）类型是 map 和 set。map 中的元素是一些**关键字-值**（key-value）对：关键字起到索引的作用，值则表示与索引相关联的数据。set 中每个元素只包含**关键字**；set 支持高效的关键字查询操作——检查一个给定关键字是否在 set 中。

标准库提供 8 个关联容器，如下所示。这 8 个容器间的不同体现在三个维度上：

- 或者是一个 map，或者是一个 set；
- 或者不允许重复的关键字，或者允许重复的关键字；
- 或者按顺序保存元素，或者按哈希函数保存元素。

| 有序集合           |                                        |
| ------------------ | -------------------------------------- |
| map                | 关联数组；保存关键字-值对              |
| multimap           | 关键字可重复出现的 map                 |
| set                | 关键字即值；只保存关键字               |
| multiset           | 关键字可重复出现的 set                 |
| **无序集合**       |                                        |
| unordered_map      | 哈希函数组织的 map                     |
| unordered_multimap | 哈希函数组织的 map；关键字可以重复出现 |
| unordered_set      | 哈希函数组织的 set；                   |
| unordered_multiset | 哈希函数组织的 set；关键字可以重复出现 |

类型 map 和 multimap 定义在头文件 map 中；set 和 multiset 定义在头文件 set 中；无序容器则定义在头文件 unordered_map 和 unordered_set 中。

## 1.1 定义关联容器

当定义一个 map 时候，必须既指明**关键字类型**又指明**值类型**；而定义一个 set 时，只需指明**关键字类型**。

**初始化 multimap 或 multiset**

一个 map 或 set 中的关键字必须是唯一的，即，对于一个给定的关键字，至多有一个元素的关键字等于它。容器 multimap 和 multiset 没有此限制，它们都允许多个元素具有相同的关键字。

## 1.2 有序容器对关键字类型的要求

关联容器对其关键字类型有一些限制。对于无序关联容器要求在第 3 节中介绍。对于有序关联容器，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的 `<` 运算符来比较两个关键字。

在映射类型中，关键字类型是元素的第一部分类型；在集合类型中，关键字类型就是元素类型。

**有序容器的关键字类型**

我们可以提供自己定义的操作来代替关键字上的 `<` 运算符，所提供的操作必须在关键字类型上定义一个**严格弱序**（即 “小于等于” ）。

**关键字类型的比较函数**

用来组织一个容器中元素的操作的类型也是该容器类型的一部分。为了指定自定义的操作，必须在定义关联容器类型时提供此操作的类型。

```c++
multiset<Sales_data, decltype(compareIsbn) *> bookstore(compareIsbn);
```

## 1.3 pair 类型

在介绍关联容器之前，我们需要了解名为 pair 的标准库类型，它定义在头文件 utility 中。

一个 pair 类型保存两个数据成员。类似容器，pair 是一个用来生成特定类型的模板。当创建一个 pair 时，我们必须提供两个类型名，pair 的数据成员将具有对应的类型，且 pair 的数据成员是 public 的。pair 上的操作如下：

```c++
pair<T1, T2> p;				// p 是一个成员类型为 T1 和 T2 的 pair，两个成员都进行了值初始化
pair<T1, T2> p(v1, v2);		// p 是一个成员类型为 T1 和 T2 的 pair，两个成员分别用 v1、v2 初始化
pair<T1, T2> p={v1, v2};	// 等价于 p(v1, v2)
make_pair(v1, v2);			// 返回一个用 v1、v2 初始化的 pair。pair 类型从 v1、v2 类型推断出来

p.first						// 返回 p 的名为 first 的数据成员
p.second					// 返回 p 的名为 second 的数据成员

p1 == p2					// 判断两个 pair 是否相等。当 first 和 second 成员 
p1 != p2					// 都相等时，两个 pair 才相等
p1 relop p2					// 关系运算符 <、<=、>、>=
```

## 1.4 关联容器迭代器

当解引用一个关联容器迭代器时，我们会得到一个类型为容器 value_type 的值。

- 对 map 而言，value_type 是一个 pair 类型，保存关键字-值对，其 first 成员保存只读（const 类型）的关键字；second 成员保存值。
- 对 set 而言，value_type 是一个 key_type 类型，只读（const 类型）；且 set 的迭代器类型虽然有 iterator 和 const_iterator，但两种类型都只允许读访问 set 中的元素。

# 2. 关联容器操作

除了第 9.1 节列出的类型，关联容器还定义了如下类型别名

| 类型别名    |                                                              |
| ----------- | ------------------------------------------------------------ |
| key_type    | 此容器类型的关键字类型                                       |
| mapped_type | 每个关键字关联的类型；只适用于 map                           |
| value_type  | 此容器类型的元素类型；<br />对于 map，为 pair<const key_type, mapped_type><br />对于 set，为 key_type； |

## 2.1 添加元素

```c++
// 添加元素
c.insert(v)				// v 是 value_type 类型的对象；args 用来构造一个元素。
c.emplace(v)			// 对于 map 和 set，只有当元素的关键字不在 c 中时才插入（或构造）元素，函数
    					// 返回一个 pair，该 pair 包含一个迭代器，指向具有给定关键字的元素；一个指示
    					// 插入是否成功的 bool 值。
    					// 对于 multimap 和 multiset，总会插入（或构造）元素，函数返回一个指向新元
    					// 素的迭代器。
    
c.insert(b, e)			// b 和 e 是迭代器，表示 c::value_type 类型值的范围；il 是这种值的花括号列
c.insert(il)			// 表。函数返回 void。对于 map 和 set，只插入关键字不在 c 中的元素。对于 
    					// multimap 和multiset，则会插入范围内的每个元素。
    
c.insert(p, v)			// 类似 insert(v) 或 emplace(args)，但将迭代器 p 作为一个提示，指出从哪里
c.emplace(p, args)		// 开始搜索新元素应存储的位置。返回一个迭代器，指向具有给定关键字的元素。
```

## 2.2 删除元素

```c++
// 删除元素
c.erase(p)				// 从 c 中删除迭代器 p 指定的元素。p 必须指向 c 中一个真实元素，不能等于
    					// c.end()。返回一个指向 p 后面的元素的迭代器
c.erase(b, e)			// 从 c 中删除迭代器 b 和 e 所表示的范围中的元素。返回 e

c.erase(k)				// 从 c 中删除每个关键字为 k 的元素。返回一个 size_type 的值，表示删除
    					// 元素的数量
```

## 2.3 访问/查找元素

### 1. 下标操作

map 和 unordered_map 容器提供了下标运算符和一个对应的 at 函数。multimap 和 unordered_multimap 不支持下标操作，因为这些容器中可能有多个值与一个关键字相关联。set 不支持下标操作，因为 set 中没有与关键字相关联的值。

对一个 map 使用下标操作，其行为与 array 或 vector 上的下标操作有很大不同：使用一个不在容器中的关键字作为下标，会添加一个具有此关键字的元素到 map 中。

```c++
// map 和 unordered_map 的下标操作
c[k]					// 返回关键字为 k 的值；如果 k 不在 c 中，添加一个关键字为 k 的元素并初始化
c.at[k]					// 访问关键字为 k 的值，带参数检查；如果 k 不在 c 中，抛出一个
    					// out_of_range 异常
```

通常情况下，解引用迭代器返回的类型与下标运算符返回的类型相同，为 value_type 对象。但对 map 则不然：当解引用 map 迭代器时，会得到一个value_type 对象；但当对 map 进行下标操作时，会得到 mapped_type 对象。

### 2. 查找元素

对于不允许重复关键字的容器，find 和 count 没什么区别；但对于允许重复关键字的容器，count 还会做更多的工作：如果元素在容器中，它还会统计有多少个元素有相同的关键字。

如果不需要计数，最好使用 find。

```c++
// 查找元素
c.find(k)				// 返回一个迭代器，指向第一个关键字为 k 的元素。若 k 不在容器中，则返回
    					// 尾后迭代器
c.count(k)				// 返回关键字等于 k 的元素的数量。对于不允许重复关键字的容器，返回 0 或 1

// lower_bound 和 upper_bound 不支持无序关联容器
c.lower_bound(k)		// 返回一个迭代器，指向第一个关键字不小于 k 的元素
c.upper_bound(k)		// 返回一个迭代器，指向第一个关键字大于 k 的元素
c.equal_range(k)		// 返回一个迭代器 pair，表示关键字等于 k 的元素的范围。若 k 不存在，pair 
						// 的两个成员均等于 c.end()
```

如果 lower_bound 和 upper_bound 返回类型相同的迭代器，则给定关键字不在容器中。

# 3. 无序关联容器

新标准定义了 4 个**无序关联容器**（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个**哈希函数**（hash function）和关键字类型的 **== 运算符**。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。

无序容器除了提供与有序容器相同的操作（find、insert 等）外，还提供了哈希管理操作。

**管理桶**

无序容器在存储上组织为一个桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。

容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。

因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。

```c++
// 桶迭代
local_iterator			// 可以用来访问桶中元素的迭代器类型
const_local_iterator	// 桶迭代器的 const 版本
c.begin(n)  c.end(n)	// 返回第 n 个桶的首元素迭代器和尾后迭代器，pair 类型
c.cbegin(n) c.cend(n)	// 与上面两个函数类似，但返回 const_local_iterator

// 桶接口
c.max_bucket_count()	// 容器能容纳的桶的最大数目
c.bucket_count()		// 容器正在使用的桶的数目
c.bucket_size(n)		// 第 n 个桶中有多少个元素
c.bucket(k)				// 关键字为 k 的元素在哪个桶中

// 哈希策略
c.max_load_factor()		// 最大装填因子，容器允许的每个桶的平均元素数量。容器会自动添加新的桶，满足
    					// load_factor <= max_load_factor
c.load_factor()			// 实际装填因子。容器中的每个桶的平均元素数量，返回 float 值

c.rehash(n)				// 重组存储，使得 bucket_count >= n 且
						// bucket_count > size/max_load_factor
c.reserve(n)			// 重组存储，使得容器可以保存 n 个元素且不必 rehash
```

**无序容器对关键字类型的要求** 

默认情况下，无序容器使用一个 hash<key_type> 类型的对象来生成每个元素的哈希值，还使用关键字类型的 == 运算符来比较元素。即首先对关键字计算 hash 值，然后使用 == 运算符判断是不是同一个元素。标准库为内置类型（包括指针）、string 和 smart pointer定义了 hash。因此，我们可以直接定义关键字是内置类型（包括指针）、string 和 smart pointer 的无序容器。

在定义关键字类型为自定义类类型的无序容器时，我们需要重载 hash 函数；如果自定义类类型没有定义 == 运算符，我们还需要定义重载 == 运算符。