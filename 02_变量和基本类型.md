<center>02. 变量和基本类型</center>
-----
[TOC]

C++语言定义了几种基本内置类型（如整型、浮点型等基本数据类型，引用、指针等复合类型），同时也为程序员提供了自定义数据类型的机制。基于此，C++标准库定义了一些更加复杂的数据类型，比如字符串和向量等。本章将主要讲述内置类型，并带领大家初步了解C++语言是如何支持更复杂数据类型的。

# 1. 基本内置类型

C++ 定义了一套包括**算术类型**（arithmetic）和**空类型**（void）在内的基本数据类型。

## 1.1 算术类型

算术类型分为两类：**整型**（包括字符和布尔类型在内）和**浮点型**。算术类型的尺寸在不同机器上有所差别，取决于编译器，但通常如下：

|    类型     |      含义      |   最小尺寸    | 常规尺寸 |
| :---------: | :------------: | :-----------: | :------: |
|    bool     |    布尔类型    |    未定义     |   8 位   |
|    char     |      字符      |     8 位      |   8 位   |
|   wchar_t   |     宽字符     |     16 位     |  32 位   |
|  char16_t   |  Unicode 字符  |     16 位     |  16 位   |
|  char32_t   |  Unicode 字符  |     32 位     |  32 位   |
|    short    |     短整形     |     16 位     |  16 位   |
|     int     |      整形      |     16 位     |  32 位   |
|    long     |     长整形     |     32 位     |  64 位   |
|  long long  |     长整形     |     64 位     |  64 位   |
|    float    |  单精度浮点型  | 6 位有效数字  |  32 位   |
|   double    |  双精度浮点型  | 10 位有效数字 |  64 位   |
| long double | 扩展精度浮点型 | 10 位有效数字 |  128 位  |

**带符号类型和无符号类型**

除去布尔类型和扩展的字符型之外，**其他整型**可以划分为**带符号的**（signed）和**无符号的**（unsigned）两种。

类型 char 被分为了3 种：char、signed char 和 unsigned char。尽管 char 型有 3 种，但是表现形式却只有两种：带符号的和无符号的。类型 char 实际上会表现为上述两种形式的一种，具体由编译器决定。

类型 short、int、long 和 long long 都是带符号的，通常在这些类型名前添加 unsigned 就可以得到无符号类型。

## 1.2 类型转换

如果表达式里有带符号类型和无符号类型时，有符号类型会自动地转换为无符号类型，可能会出现异常结果。

# 2. 变量

**变量**：提供一个具名的、可供程序操作的存储空间。C++ 中，**变量**和**对象**一般可以互换使用。

- **初始化**：当对象在创建时获得了一个特定的值，我们说这个对象被**初始化**（initialized）了。初始化和赋值是两个完全不同的操作。

  > 初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值；而赋值的含义是把对象的当前值擦除，而以一个新值来替代。

- **默认初始化**：如果定义变量时没有指定初值，则变量被**默认初始化**（default initialized）。如果**内置类型**的变量未被显示初始化，它的值由定义的位置、存储类型决定。

  - 全局变量被初始化为 0；
  - static 修饰的局部变量被初始化为 0；
  - 未被 static 修饰的局部变量不被初始化，其值未定义。

  每个类各自决定其初始化对象的方式。

- **列表初始化**：使用一组 `{}` 内的初始值进行初始化，称为**列表初始化**（list initialized）。详见 3.3。

## 2.1 变量声明和定义的关系

- **声明**（declaration）：使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。分为引用型声明和定义型声明。
  - 引用型声明：声明一个变量而非定义它。
  - 定义型声明：声明一个变量并定义它。

- **定义**（definition）：负责创建与名字关联的实体。

**从右向左阅读**方便理解声明或定义的含义。大部分情况下的声明为定义型声明。如果想引用型声明，就在变量名前添加关键字 `extern`，而且不要显式地初始化变量：

```c++
extern int i;
```

> 变量能且只能被定义一次，但是可以被多次声明。

## 2.2 标识符

C++ 的**标识符**（identity）由字母、数字和下画线组成，必须以字母或下画线开头。关键字不能被用作标识符。

用户自定义的标识符中不能连续出现两个下画线；不能以下画线连大写字母开头；全局标识符不能以下画线开头。

# 3. 复合类型

**复合类型**（compound type）是基于其他类型定义的类型。C++ 语言有多种复合类型，本章将介绍其中的两种：引用和指针。引用必须初始化、指针不用。

## 3.1 引用

**引用**（reference）为对象起了另外一个名字。通过将声明符写成 `&d` 的形式来定义引用类型。

```c++
int ival = 1024;
int &refVal = ival;	// 声明引用 refVal, 指向 ival（即 refVal 是 ival 的另一个名字）
```

引用本身不是一个对象，所以不能定义引用的引用。

## 3.2 指针

**指针**（pointer）实现了对其他对象的间接访问。然而指针与引用相比又有很多不同。其一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象；其二，指针无须在定义时赋值。通常将声明符写成 `*d` 的形式定义指针类型。

```c++
int ival = 42;
int *p = &ival;	// p 存放变量 ival 的地址，或者说 p 是指向变量 ival 的指针
void *pv;		// void * 是一种特殊的指针类型，可用于存放任意对象的指针
```

**指针值**：指针的值应属下列 4 种状态之一：

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针，即指针没有指向任何对象
- 无效指针，也就是上述情况之外的其他值

**指向指针的指针**

通过 * 的个数可以区分指针的级别，即：* 表示普通的指针；** 表示指向指针的指针。

由于引用本身不是一个对象，故不能定义指向引用的指针。但指针是对象，所以存在指向指针的引用。

# 4. const 限定符

const 对象一旦创建后其值就不能改变，所以 const 对象必须初始化。

默认情况下，const 对象仅在当前文件内有效。为了只在一个文件中定义，而在其他多个文件中声明并使用它，我们可以在 const 对象声明还是定义时都添加 extern 关键字，这样只需定义一次就行。

## 4.1 引用和 const

**对常量的引用**

可以把引用绑定到 const 对象上，就像绑定到其他对象上一样，我们称之为**对常量的引用**（reference to const）。对常量的引用不能被用作修改它所绑定的对象。

```c++
const int ci = 1024;
const int &r1 = ci;		// 正确，引用及其对应的对象都是常量
int &r2 = ci;			// 错误，试图让一个非常量引用指向一个常量对象
```

对常量的引用可能引用一个非常量对象，如下示例，具体分析见 4.2

```c++
int i = 42;
int &r1 = i;			// 引用 r1 绑定对象 i
const int &r2 = i;		// r2 也绑定对象 i，但是不允许通过 r2 修改 i 的值
```

## 4.2 指针和 const

**指向常量的指针**

与引用一样，可以把指针指向 const 对象，称为**指向常量的指针**（pointer to const）。指向常量的指针不能用于改变其所指对象的值。

```c++
const double pi = 3.14;
const double *cptr = &pi;	// 正确，cptr 可以指向一个双精度常量
*cptr = 42;					// 错误，不能给 cptr 赋值
```

指向常量的指针也没有规定其所指的对象必须是一个常量。原因如下：

> 所谓的指向常量的引用或指针，不过是指针或引用 ”自以为是“ 罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。

**常量指针（const pointer）**

指针是对象而引用不是，因此就像其他类型一样，允许把指针本身定位常量。**常量指针**（const pointer）必须初始化，而且一旦初始化完成，则它的值（即指向的地址）就不能改变了。

```c++
int errNumb = 0;
int *const curErr = &erNumb;	// curErr 将一直指向 errNumb
```

## 4.3 顶层/底层 const

如前所述，指针本身是一个对象，指针又可以指向另外一个对象。故，指针本身是不是常量和指针所指的是不是常量就是两个互相独立的问题。名词**顶层 const**（top-level const）表示指针本身是一个常量；**底层 const**（low-level const）表示指针所指的对象是一个常量。

更一般的，顶层 const 表示对象本身是常量，这一点对任何对象都适用。底层 const 则与引用、指针等复合类型的**基本类型**有关。

## 4.4 常量表达式和 constexpr

### 1. 常量表达式

**常量表达式**（const expression）：指值不会改变并且在编译过程就能得到计算结果的表达式。

### 2. constexpr 变量

由于很难分辨一个初始值到底是不是常量表达式，C++11 新标准规定，运行将变量声明为 **constexpr** 类型以便由编译器来验证变量的值是否为一个常量表达式。

声明为 constexpr 的变量一定是个常量，而且必须用常量表达式初始化。

**注意**：如果在 constexpr 的声明中出现了指针，那么 constexpr 仅对指针有效，与指针所指的对象无关。

```c++
constexpr int *p = nullptr;		// p 是一个指向整数的常量指针
```

**字面值类型**

截止目前为止，只有算术类型、引用和指针都属于字面值类型。

# 5. 类型的处理

## 5.1 类型别名

**类型别名**（type alias）：是某种类型的另一个名字。有两种方法可用于定义类型别名

- 传统方法 关键字 **typedef**

  ```c++
  typedef double wages;
  ```

- 别名声明 关键字 **using**

  ```c++
  using wages = double;
  ```

## 5.2 auto 类型说明符

**auto**：C++11 新标准引入，让编译器替我们去分析表达式所属的类型。故，auto 定义的变量必须要有初始值。一条 auto 语句中声明多个变量时，该语句中所以变量的初始类型都必须一样。

1. auto 使用引用对象的类型作为 auto 的类型，即当引用作为初始值时，auto 的类型为引用对象的类型；

   ```c++
   int i = 0, &r = i;
   auto a = r;			// a 是一个整型
   ```

2. auto 一般会忽略掉顶层 const，同时保留底层 const；

   ```c++
   const int ci = i, &cr = ci;
   auto b = ci;		// b 是一个整型（ci 的顶层 const 被忽略）
   auto e = &ci;		// e 是一个指向整型常量的指针（& of a const type is low-level const）
   ```

3. 设置一个类型为 auto 的引用时，初始值中的顶层常量属性仍然保留。

   ```c++
   auto &g = ci;		// g 是一个整型常量引用，绑定到 ci
   ```

## 5.3 decltype 类型说明符

**decltype**：C++11 新标准引入，选择并返回操作数的数据类型。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。

1. decltype 处理引用和顶层 const 的方式与 auto 有些许不同。
   - 如果decltype 使用的表达式是一个变量，则返回该变量的类型（包括引用和顶层 const）；
   - 如果使用的表达式是解引用操作，返回引用类型。
2. decltype 的结果类型与表达式形式密切。
   - 如果 decltype 使用的表达式是加上了括号的变量，返回引用类型。



C++ 关键字

```c++
// 数据类型		20
void
bool true false
char wchar_t char16_t char32_t
int short long signed unsigned
float double
enum
struct union
typedef
decltype
nullptr

// 存储类型		7
auto
register
static
extern
const constexpr
volatile

// 运算符		1
sizeof
    
// 控制语句		15
goto
return
break continue
if else
switch case default
do for while
throw try catch

// 动态内存		2
new delete

// 类型相关		6
static_cast 
dynamic_cast 
const_cast
reinterpret_cast
typeid typename


// 面向对象		8
class friend 
public private protected
this
virtual
inline

// 命名空间		2
using namespace

// 其他		  7
asm explicit export mutable operator template
      
// C++11新增	 5=10-5
alignas
alignof
noexcept
static_assert
thread_local
```











