<center>13. 拷贝控制</center>
-----
[TOC]

当定义一个类时，我们显式地或隐式地指定在此类型上的拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：**拷贝构造函数**（cpoy constructor）、**移动构造函数**（move constructor）、**拷贝赋值运算符**（copy-assignment operator）、**移动赋值运算付**（move-assignment operator）、**析构函数**（destructor）。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为**拷贝控制操作**。

# 1. 拷贝、赋值和析构

我们将以最基本的操作——拷贝构造函数、拷贝赋值运算符和析构函数作为开始。在第 6 节中将介绍移动操作。

## 1.1 拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**。

```c++
class Foo {
  public:
    Foo();            		// 默认构造函数
    Foo(const Foo &); 		// 拷贝构造函数
};
```

拷贝构造函数的第一个参数必须是一个引用类型。

**合成拷贝构造函数**

如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，**即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数**。

对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象；一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非 static 成员拷贝到正在创建的对象中。每个成员的类型决定它如何拷贝：

- 对于类类型的成员，使用其拷贝构造函数来拷贝；
- 对于内置类型的成员，直接拷贝；
- 对于数组，根据数组元素的类型，逐元素使用其拷贝构造函数来拷贝或直接拷贝。

**拷贝初始化**

当使用**值初始化**时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当使用**拷贝初始化**时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还需要进行类型转换。拷贝初始化不仅在我们用 `=` 定义变量时会发生，在下列情况在也会发生：

- 将一个对象作为实参传递给一个非引用类型的形参；
- 从一个返回类型为非引用类型的函数返回一个对象；
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

## 1.2 拷贝赋值运算符

**重载运算符**（overlorded operator）本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 `operator=` 的函数。类似于任何函数，运算符函数也有一个返回类型和一个参数列表。

```c++
class Foo {
  public:
    Foo &operator=(const Foo &);	// 赋值运算符
};
```

> 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

**合成拷贝赋值运算符**

与拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。

对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值；一般情况下，拷贝赋值运算符会将右侧运算对象的每个非 static 成员赋予左侧运算对象的对应成员。合成拷贝赋值运算符返回一个指向其左侧运算符对象的引用。

## 1.3 析构函数

析构函数执行与构造函数相反的操作：构造函数初始化对象的非 static 数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。

```c++
class Foo {
  public:
    ~Foo();							// 析构函数
};
```

由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。

如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化；在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。

在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员的析构函数；销毁内置类型的成员，则什么也不需要做（内置类型没有析构函数）。

**合成析构函数**

与拷贝构造函数一样，如果一个类未定义自己的析构函数时，编译器会为它生成一个合成析构函数。

对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。

**调用析构函数**

无论何时一个对象被销毁，就会自动调用其析构函数：

- 变量在离开其作用域时被销毁；
- 当一个对象被销毁时，其成员被销毁；
- 当一个容器（无论是标准库容器还是数组）被销毁时，其元素被销毁；
- 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁；
- 对于临时对象，当创建它的完整表达式结束时被销毁。

> 当指向一个对象的指针或引用离开作用域时，该指针或引用被销毁，但指向的对象不会被销毁，也不会执行析构函数。

## 1.4 三/五法则

如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。

**需要析构函数的类也需要拷贝和赋值操作**

通常，对析构函数的要求要比对拷贝构造函数或赋值运算符的需求更为明显。如果某个类**需要一个析构函数**，我们几乎可以肯定它也**需要一个拷贝构造函数和一个拷贝赋值运算符**。

**需要拷贝操作的类也需要赋值操作，反之亦然**

如果某个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符，反之亦然——如果某个类需要一个拷贝赋值运算符，几乎可以肯定它也需要一个拷贝构造函数。

## 1.5 使用 `= default`

当我们在类内用 `= default` 修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员函数是内联函数，应该只对成员的类外定义使用 `= default`。

## 1.6 阻止拷贝

 