<center>07. 类</center>
-----
[TOC]

类的基本思想是**数据抽象**（data abstraction）和**封装**（encapsulation）。数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）**分离**的编程技术。

- 类的接口包括用户所能执行的操作，即接口函数，包括类的公有成员函数和类外的接口函数；
- 类的实现包括类的数据成员、负责接口实现的函数（如上的接口函数）以及定义类所需要的各种私有成员函数。

封装实现了类的接口和实现的分离。分离的意思是：封装后的类隐藏了它的实现细节，也就是说，**类的用户只能使用接口而无法访问实现部分**。

类要想实现数据抽象和封装，首先需要定义一个**抽象数据类型**。在抽象数据类型中，由类的设计者负责考虑类的实现过程；使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。

# 1. 数据抽象

根据目前掌握的知识，我们暂时将**类的成员**分为**成员变量**（data members，也称为数据成员）和**成员函数**（member function）两种。这样，就方便我们分析类的接口和实现了。以下为个人理解：

- 类的接口包括用户所能执行的操作，==包括类的公有成员函数、类相关的非成员函数==；
- 类的实现包括类的成员变量、==负责接口实现的函数以及定义类所需要的各种私有函数==。

## 1.1 定义类

```c++
struct Sales_data {
    // 成员变量
    string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
    // 成员函数
    string isbn() const { return bookNo; }
    Sales_data &combine(const Sales_data &);
    double avg_price() const;
};
// Sales_data 外的接口函数
Sales_data add(const Sales_data &, const Sales_data &);
ostream &print(ostream &, const Sales_data &);
istream &read(istream &, Sales_data &);
```

定义在类内的函数是隐式的 inline 函数。事实上，定义在 .h 文件内的函数都是内联函数。对于 C++ 中的 .h 文件和 .c 文件的区分在本章末尾给出。

### 1. 定义成员函数

尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。

```c++
// 类的内部定义成员函数
string isbn() const { return bookNo; }

// 类的外部定义成员函数
double Sales_data::avg_price() const {
    if (units_sold)
        return revenue / units_sold;
    else
        return 0;
};
```

对比来看，类外部定义的成员函数的名字**必须包含它所属的类名**。

### 2. 引入 this

成员函数通过一个名为 **this** 的额外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用**请求该函数的对象地址**初始化 this。因此，在成员函数内部，任何对类成员的直接访问都被看做 this 的隐式引用。不过我们可以在成员函数内部使用 this，如下所示，尽管没有必要。

```c++
string isbn() const {return this->bookNo; }
```

因为 this 的目的总是指向请求成员函数的对象，所以 this 是一个**常量指针**（例如在 Sales_data 类中，this 指针的类型为 `Sales_data *const` ）。由于 this 是一个常量指针，故不允许改变 this 中保存的地址。

### 3. 引入 const 成员函数

默认情况下，this 是指向类类型非常量版本的常量指针，这就意味着我们不能把 this 绑定到一个常量对象上。为了将 this 绑定到常量对象上，我们可以在参数列表后面加上 const，表示 this 是一个指向常量的指针。像这样使用 const 的成员函数被称作**常量成员函数**（const member function）。

### 4. 类作用域

由于类本身就是一个作用域，所以类的成员变量和成员函数都位于类的作用域内。这也是为什么类外部定义的成员函数的名字必须包含它所属的类名。这个是由作用域决定的。

## 1.2 定义类相关的非成员函数

一般来说，如果非成员函数是类的接口的组成部分，则这些函数的声明应该与类在同一个文件中。

## 1.3 构造函数

每个类都分别定义了它的对象被初始化的方式，类通过一个或多个**特殊的成员函数**来控制其对象的初始化过程，这些对象叫做**构造函数**（constructor）。构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创造，就会执行构造函数。

构造函数的名字和类名相同。和其他函数不一样的是：构造函数没有返回类型；和其他函数类似的是：构造函数有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，和其他重载函数差不多。

构造函数不能被声明成 const 的，但构造函数可以构造 const 对象。

**默认构造函数（default constructor）**

默认构造函数无须任何实参。

**合成的默认构造函数（synthesized default constructor）**

如果**类没有显式地定义构造函数**，编译器就会隐式地定义一个默认构造函数。这个构造函数又被称为合成的默认构造函数。对于大多数类来说，合成的默认构造函数将按照如下规则初始化类的数据成员：

- 如果有类内的初始值，用它来初始化成员。
- 否则，默认初始化该成员。

合成的默认构造函数只适合非常简单的类，对一个普通的类来说，必须定义它自己的默认构造函数，原因有三：

1. 编译器只有在发现类不包含任何构造函数的情况下才会提我们生成一个默认构造函数。
2. 对于某些类来说，合成的默认构造函数可能执行错误的操作。
3. 有的时候编译器不能为某些类合成默认的构造函数。

**构造函数初始值列表**

```c++
Sales_data(const string &s) : bookNo(s) {};
Sales_data(const string &s, unsigned n, double p) 
    : bookNo(s), units_sold(n), revenue(p * n) {};
```

冒号和花括号之间的部分称为构造函数初始值列表。花括号定义（空的）函数体。

## 1.4 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。

- 拷贝：例如初始化对象，以值的形式传递或返回一个对象等；
- 赋值：例如使用赋值运算符；
- 销毁：例如一个局部对象会在创建它的块结束时被销毁，vector 对象销毁时存储在其中的对象也会被销毁。

> 拷贝与赋值的最大区别在于：= 左侧是在定义对象时称为拷贝；= 左侧是对象时称为赋值。

在 C++ 中，如果你没有声明任何构造函数，编译器会自动声明一个**默认构造函数**；此外对于拷贝、赋值和析构，编译器也会自动声明相应的函数，如下：

```c++
class Empty{
	Empty() { ... };							// 默认构造函数 default constructor
    Empty(const Empty &ths) { ... };			// 拷贝构造函数 copy constructor
    ~Empty() { ... };							// 析构函数	destructor
    
    Empty &operator=(const Empty &ths) { ... };	// 赋值	copy assignment operator
};
```

当然，我们可以对上述函数进行重写。此外，我们还可以定义自己需要的构造函数。

# 2. 封装

在 C++ 中，我们使用**访问说明符**（access specifiers）加强类的封装性：

- 定义在 **public** 说明符之后的成员在整个程序内可被访问，public 成员定义类的接口。
- 定义在 **private** 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private 部分封装了类的实现细节。

## 2.1 class/struct

在 C++ 语言中，**class** 和 **struct** 都可以定义类，唯一的区别是 class 和 struct 的默认访问权限不太一样。  class 默认是 private 的；struct 默认是 public 的。

## 2.2 友元

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的**友元**（friend）。如果类想把一个函数作为它的友元，只需要增加一条以 **friend** 关键字开始的函数声明语句即可。

友元声明只能出现在类定义的内部。友元声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须**在友元声明之外再专门对函数进行一次声明**。

# 3. 类的其他特性

## 3.1 类成员再探

**可变数据成员**

一个**可变数据成员**（mutable data member）永远不会是 const，即使它是 const 对象的成员。使用关键字 **mutable** 可将一个数据成员变为可变数据成员。

```c++
class Screen {
  public:
    void some_member() const;

  private:
    mutable size_t access_ctr;
};
void Screen::some_member() const { ++access_ctr; }
```

**成员函数**

定义在类内部的成员函数是隐式的内联函数；类内部的成员函数声明时可声明为内联函数，不过最好在类外部定义的地方说明 inline。

类的成员函数也可以被重载。

## 3.2 返回 *this 的成员函数

1. 对于返回 *this 的非 const 成员函数，如果以引用的形式返回 *this（例如返回 `Screen &`），则返回的是对象本身；如果以对象的形式返回 *this（例如返回 `Screen`），则返回的是对象的副本。因为返回引用的函数是左值的。
2. 对于返回 *this 的 const 成员函数，如果以引用的形式返回 *this（例如返回  `const Screen &`），则返回的类型是对常量的引用；如果以对象的形式返回 *this（例如返回 `Screen`），则返回的是对象的副本。

## 3.3 类类型与作用域

**类类型**

每个类定义了唯一的类型，类名决定一个类类型。

**类的作用域**

一个类就是一个作用域。因此，在类的外部定义成员函数时：必须提供类名和函数名；如果返回类型为类成员，也必须提供类名和返回类型。

## 3.4 友元再探

友元可以是函数、类或者类的成员函数。友元能定义在类的内部，这样的函数是隐式内联的。

如果在类的内部定义了友元函数，也必须在类的外部提供相应的声明从而使得函数可见。

# 4. 构造函数再探

## 4.1 默认构造函数

**定义默认构造函数**

默认构造函数无需任何实参，即不接受任何实参的构造函数就是一个默认构造函数。那么如何定义一个默认构造函数呢？

- 合成的默认构造函数：当我们的类没有显式地定义构造函数时，编译器就会为我们隐式地定义一个默认构造函数，称为合成的默认构造函数，存在一些弊端。

- 默认构造函数：只要是不接受任何实参的构造函数。例如：

  ```c++
  Sales_data() = default;						  // 等同于合成的默认构造函数
  Sales_data() : .../*构造函数初始值列表*/... {};	// 中间跟构造函数初始值列表的默认构造函数
  ```

**执行默认构造函数**

当对象被默认初始化或值初始化时自动执行默认构造函数。

> 千万不要这么写：`Sales_data obj();`，这是定义一个返回值为类对象的函数，不是值初始化。

## 4.2 拷贝构造函数

如果一个构造函数的第一个参数是自身类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。我们会在接下来的章节中介绍拷贝构造函数。

**执行拷贝构造函数**

当对象被拷贝初始化时自动执行拷贝构造函数。

## 4.3 普通构造函数

我们显式地定义的，规则不同于默认构造函数和拷贝构造函数的构造函数在我个人认为是普通构造函数，初始化类的对象。

**执行普通构造函数**

当对象被直接初始化或列表初始化（聚合初始化是列表初始化的一种）时自动执行普通构造函数。

## 4.4 委托构造函数

一个委托构造函数（delegating constructor）使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把自己的一些（或全部职责）委托给了其他构造函数。

## 4.5 转换构造函数

**隐式的类类型转换**

类也有隐式转换规则。如果构造函数只接受一个实参，则它定义了转换此类类型的隐式转换机制，有时我们把这种构造函数称作转换构造函数（converting constructor）。不过要注意如下情况：

- 只允许一步类型转换；
- 类类型转换不是总有效；

## 4.6 聚合类

**聚合类**（aggregate class）使得用户可以直接访问其成员，并且具有特定的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：

- 所以成员都是 public 的。
- 没有定义任何构造函数。
- 没有类内初始值。
- 没有基类，也没有 virtual 函数。

不过显式地初始化类的对象的成员存在三个明显的缺点：

- 要求类的所以成员都是 public 的。
- 将正确初始化每个对象的重任交给了用户，过程冗长多于且容易出错。
- 添加或删除一个成员之后，所以的初始化语句都要更新。

# 5. 类的静态成员

## 5.1 声明静态成员

在成员的声明之前加上关键字 **static** 使得其与类关联在一起，这样就声明了静态成员。类的静态成员存在于任何对象之外。

- 对于静态成员变量，静态成员变量不和任何对象绑定在一起。静态成员变量可以是常量、引用、指针、类类型。
- 对于静态成员函数，静态成员函数也不与任何对象绑定在一起，且不包含 this 指针。故静态成员函数不能生命成 const 的，也不能在函数体内使用 this 指针。

## 5.2 定义静态成员

**静态成员变量**

静态成员变量不属于类的任何一个对象，所以它们不是在创建类的对象时定义的，也不是类的构造函数初始化的。

必须在类的外部定义和初始化每个静态成员变量，且只能定义一次。

特殊情况：一个 static const 成员变量可以在类内部被初始化。不过也应该在类的外部定义一下该成员变量。

**静态成员函数**

与其他成员函数一样，既可以在类的内部也可以在类的外部定义静态成员函数。

在类外部定义的静态成员时不能重复关键字 static。

# 6. 头文件/源文件

|             | 非模板类型（none-template）                                  | 模板类型（template）                     |
| ----------- | ------------------------------------------------------------ | ---------------------------------------- |
| 头文件 .h   | 全局变量的声明（需要 extern 修饰）<br />全局函数的声明<br />inline 的全局函数的定义（显式内联） | inline 的全局模板函数的声明和定义        |
|             | 类的定义<br />类内部：成员变量和成员函数的声明<br />类内部：成员函数的定义（隐式内联）<br />类内部：友元的声明<br />类内部：友元函数的定义（隐式内联） | 模板类的定义<br />模板类成员的声明和定义 |
| 源文件 .cpp | 全局变量的定义（及初始化）<br />全局函数的定义               | 无                                       |
|             | 类的成员函数的定义<br />类的友元函数的定义                   |                                          |

