<center>12. 动态内存</center>
-----
[TOC]

**静态内存**用来保存全局变量、局部 static 对象、类 static 成员变量；**栈内存**用来保存局部自动变量。分配在静态内存或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；static 对象在使用之前分配，在程序结束时销毁。

除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称为自由空间或**堆**（heap）。程序用堆来存储**动态分配**（dynamically allocate）的对象——即，那些在程序运行时分配的对象。对象对象的生存期由程序来控制，也就是说，当动态内存不再使用时，我们的代码必须显式地销毁它们。

# 1. 动态内存和智能指针

在 C++ 中，动态内存的管理是通过一对运算符来完成的：**new**，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；**delete**，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。

为了更容易（同时也更安全）地使用动态内存，新的标准库提供了两种**智能指针**（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的这两种指针的区别在于管理底层指针的方式：**shared_ptr** 允许多个指针指向同一个对象；**unique_ptr** 则 “独占” 所指向的对象。标准库还定义了一个名为 **weak_ptr** 的伴随类，它是一种弱引用，指向 **shared_ptr** 所管理的对象。这三种类型都定义在 memory 头文件中。

## 1.1 shared_ptr 类

类似 vector，智能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型，之后是所定义的这种智能指针的名字：

```c++
shared_ptr<string> p1;			// 可以指向 string
shared_ptr<list<int>> p2;		// 可以指向存储 int 的 list
```

默认初始化的智能指针保存着一个空指针。